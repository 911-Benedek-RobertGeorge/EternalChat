{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/EthernalChatIncentivized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title A simple chat contract that stores a link between users and messages on IPFS\n/// @notice You can use this contract for keeping a descentralized chat history\n/// @dev This contract implements a relatively simple way of storing messages\ncontract EthernalChatIncentivized is Ownable {\n\tstruct DataInfo {\n\t\tbytes32 cid;\n\t\t// Below is needed for the simple proof of storage done here\n\t\tbytes32 merkleRoot; // Root of the merkle tree\n\t\tuint64 sizeOfChunks; // Help checking the size of the data during proof verification\n\t\tuint64 numberOfChunks;\n\t\t//  Address of the storage provider we want to incentivize\n\t\taddress storageProvider; // This could be a list but for now only one\n\t\tbool challengeAsked;\n\t\tuint64 lastChallengeIndex;\n\t\tuint256 lastTimeRewardRedeemed; // Represent the last time the storageProvider redeemed a reward with a challenge\n\t\tuint256 allocatedEth;\n\t\tuint256 ethSpent; // total eth earned by storage providers (spent by the user)\n\t}\n\n\tstruct ProviderInfo {\n\t\tuint256 totalEthEarned;\n\t\tuint256 lastWithdrawTime;\n\t}\n\n\t/// @notice Amount of eth earned for storing files per day\n\tuint256 public constant PRICE_PER_DAY = 0.0001 ether;\n\t/// @notice Mapping of CID/DataInfo of the stored messages for each account\n\tmapping(address => DataInfo) private mapDataInfo;\n\n\t/// @notice Mapping of the storage providers rewards info\n\tmapping(address => ProviderInfo) private mapProviderInfo;\n\n\t/// @notice Amount of tokens required for storing a message\n\tevent CIDUpdated(address indexed user, bytes32 cid);\n\n\t\t/// @notice Challenge for address addr\n\tevent Challenge(address indexed addr, uint64 challengeIndex);\n\n\tmodifier OnlyStorageProvider(address addr) {\n\t\trequire(\n\t\t\tmsg.sender == mapDataInfo[addr].storageProvider,\n\t\t\t\"You need to be the storage provider for this address\"\n\t\t);\n\t\t_;\n\t}\n\n\t/// @notice Constructor function\n\tconstructor() Ownable(msg.sender) {}\n\n\t/// @notice Sets the CID (Content Identifier) for the sender of the transaction.\n\t/// @param cid The CID to set for the user.\n\t/// @param sizeOfChunks The size of each chunks. (Padding need to be applied for the last chunk if necessary)\n\t/// @param numberOfChunks The number of chunks we divided the data for the storage proof. (Total number of chunks)\n\t/// @param newMerkleRoot The calculated merkle root corresponding of the hash of each chunks, then the hash of each chunk concatenated 2-by-2...\n\tfunction setCID(\n\t\tbytes32 cid,\n\t\tuint64 sizeOfChunks,\n\t\tuint64 numberOfChunks,\n\t\tbytes32 newMerkleRoot\n\t) public {\n\t\trequire(cid != bytes32(0), \"Invalid CID\");\n\t\trequire(newMerkleRoot != bytes32(0), \"Invalid Merkle Root\");\n\t\tDataInfo storage dataInfo = mapDataInfo[msg.sender];\n\n\t\tdataInfo.cid = cid;\n\t\tdataInfo.sizeOfChunks = sizeOfChunks;\n\t\tdataInfo.numberOfChunks = numberOfChunks;\n\t\tdataInfo.merkleRoot = newMerkleRoot;\n\n\t\temit CIDUpdated(msg.sender, cid);\n\t}\n\n\t// Set Storage Provider (or update it)\n\n\t// /// @notice Adds or updates a user's storage provider\n\t/// @param addr Address of the account you are trying to set as a storage provider.\n\t// /// @dev\n\tfunction setStorageProvider(address addr) public {\n\t\tProviderInfo storage providerInfo = mapProviderInfo[addr];\n\t\tmapDataInfo[msg.sender].storageProvider = addr;\n\t\tif (providerInfo.lastWithdrawTime == 0) {\n\t\t\tproviderInfo.lastWithdrawTime = block.timestamp;\n\t\t\tproviderInfo.totalEthEarned = 0 ether;\n\t\t}\n\t\tproviderInfo.lastWithdrawTime = providerInfo.lastWithdrawTime;\n\t\tproviderInfo.totalEthEarned = providerInfo.totalEthEarned;\n\t}\n\n\t/// @notice Add funds to an existing DataInfo by sending tokens and updating\n\t/// @dev Make sure the DataInfo is non zero (has been already created)\n\tfunction addFundsForStorage() public payable {\n\t\tDataInfo storage dataInfo = mapDataInfo[msg.sender];\n\t\trequire(dataInfo.cid != bytes32(0), \"DataInfo not found\");\n\t\tdataInfo.allocatedEth += msg.value;\n\t}\n\n\t/// @notice Retrieves the CID (Content Identifier) stored for the user.\n\t/// @param addr Address of the account you are trying to access the data from\n\t/// @return The CID associated with the user.\n\t/// @dev Passes when the user has a CID stored. This function is view only, so it doesn't modify the state of the contract\n\tfunction getCID(address addr) public view returns (bytes32) {\n\t\tDataInfo memory dataInfo = mapDataInfo[addr];\n\t\trequire(dataInfo.cid != bytes32(0), \"No CID found for this address\");\n\t\treturn dataInfo.cid;\n\t}\n\n\t\n\tfunction getStorageProvider(address addr) public view returns (address) {\n\t\treturn mapDataInfo[addr].storageProvider;\n\t}\n\n\tfunction getAllocatedEthToStorageProvider(\n\t\taddress addr\n\t) public view returns (uint256) {\n\t\treturn mapDataInfo[addr].allocatedEth;\n\t}\n\n\tfunction getTotalEthToStorageProvider(\n\t\taddress addr\n\t) public view returns (uint256) {\n\t\treturn mapProviderInfo[addr].totalEthEarned;\n\t}\n\n\t\n\t//\t\t\t\t\t\t\t  //\n\t//   \t\t\t\t\t\t  //\n\t// Storage Provider functions //\n\t//   \t\t\t\t\t\t  //\n\t//   \t\t\t\t\t\t  //\n\n\n\tfunction getNumberOfChunks(address addr) public view  returns (uint64){\n\t\treturn mapDataInfo[addr].numberOfChunks;\n\t}\n\n\tfunction getChunkSize(address addr) public view  returns (uint64){\n\t\treturn mapDataInfo[addr].sizeOfChunks;\n\t}\n\n\t/// @notice Generate the challenge for the proof of Storage to use with getStorageReward.\n\t/// @param addr Address of the account you are trying to get a challenge from.\n\tfunction getChallenge(\n\t\taddress addr\n\t) public OnlyStorageProvider(addr){\n\t\tDataInfo storage dataInfo = mapDataInfo[addr];\n\t\trequire(\n\t\t\tdataInfo.cid != bytes32(0),\n\t\t\t\"No DataInfo found for this address\"\n\t\t);\n\t\trequire(\n\t\t\tblock.timestamp >= dataInfo.lastTimeRewardRedeemed + 1 days,\n\t\t\t\"Not Enough time has passed\"\n\t\t);\n\t\trequire(\n\t\t\tdataInfo.challengeAsked == false,\n\t\t\t\"You already asked for a challenge\"\n\t\t);\n\t\tdataInfo.lastChallengeIndex = uint64(block.prevrandao) % dataInfo.numberOfChunks;\n\t\tdataInfo.challengeAsked = true;\n\t\temit Challenge(addr,dataInfo.lastChallengeIndex);\n\t}\n\n\t/// @notice Get the challenge index generated before\n\t/// @param addr Address of the account you are trying to get a challenge from.\n\tfunction getChallengeIndex(address addr) public view returns(uint64){\n\t\treturn mapDataInfo[addr].lastChallengeIndex;\n\t}\n\n\tfunction verifyStorageProof(\n\t\tuint index,\n\t\tbytes32 merkleRoot,\n\t\tbytes memory chunkData,\n\t\tbytes32[] memory hashes\n\t) internal pure returns (bool) {\n\t\tbytes32 chunkHash = keccak256(chunkData);\n\t\tfor (uint i = 0; i < hashes.length; i++) {\n\t\t\tif (index % 2 == 0) {\n\t\t\t\tchunkHash = keccak256(abi.encodePacked(chunkHash, hashes[i]));\n\t\t\t} else {\n\t\t\t\tchunkHash = keccak256(abi.encodePacked(hashes[i], chunkHash));\n\t\t\t}\n\t\t\tindex = index / 2;\n\t\t}\n\t\treturn chunkHash == merkleRoot;\n\t}\n\n\t/// @notice Allows storage to reedem a partial amount of reward in token by answering to the challenge. They can do it only once per day.\n\t/// The full reedmed amount can be withdraw after a month (30days) since lastWithdrawTime see withdrawRewards()\n\t/// @param addr Address of the account you are trying to get the reward from.\n\t/// @param hashes Array of hashes allowing the proof : it should be ordered by the level in the merkle tree from the leafs.\n\t///  it should allow the proof to pass.\n\tfunction getStorageReward(\n\t\taddress addr,\n\t\tbytes memory chunkData,\n\t\tbytes32[] memory hashes\n\t) public OnlyStorageProvider(addr) {\n\t\tDataInfo storage dataInfo = mapDataInfo[addr];\n\t\tProviderInfo storage providerInfo = mapProviderInfo[\n\t\t\tdataInfo.storageProvider\n\t\t];\n\t\trequire(dataInfo.challengeAsked, \"No challenge was asked\");\n\t\trequire(\n\t\t\tmapDataInfo[addr].cid != bytes32(0),\n\t\t\t\"No DataInfo store by this address\"\n\t\t);\n\t\trequire(\n\t\t\tblock.timestamp >= dataInfo.lastTimeRewardRedeemed + 1 days,\n\t\t\t\"Not Enough time has passed\"\n\t\t);\n\n\t\trequire(\n\t\t\tdataInfo.ethSpent + PRICE_PER_DAY <= dataInfo.allocatedEth,\n\t\t\t\"The user hasn't allocated enough eth\"\n\t\t);\n\n\t\trequire(\n\t\t\tverifyStorageProof(\n\t\t\t\tdataInfo.lastChallengeIndex,\n\t\t\t\tdataInfo.merkleRoot,\n\t\t\t\tchunkData,\n\t\t\t\thashes\n\t\t\t),\n\t\t\t\"The proof of Storage is incorrect\"\n\t\t);\n\n\t\tdataInfo.lastTimeRewardRedeemed = block.timestamp;\n\t\tdataInfo.lastChallengeIndex = 0;\n\t\tdataInfo.ethSpent += PRICE_PER_DAY;\n\t\tdataInfo.challengeAsked = false;\n\t\tproviderInfo.totalEthEarned += PRICE_PER_DAY;\n\t}\n\n\t/// @notice Take out all the rewards in Eth based on the amount of tokens the address holds\n\tfunction withdrawRewards() public {\n\t\tProviderInfo storage provider = mapProviderInfo[msg.sender];\n\t\tuint256 amount = provider.totalEthEarned;\n\t\trequire(amount > 0, \"No rewards available\");\n\t\trequire(\n\t\t\tblock.timestamp >= provider.lastWithdrawTime + 30 days,\n\t\t\t\"Not Enough time has passed\"\n\t\t);\n\t\tprovider.totalEthEarned = 0;\n\t\t(bool success, ) = payable(msg.sender).call{ value: amount }(\"\");\n\t\trequire(success);\n\t}\n\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}